# redis 为什么快？
1. 纯内存操作，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在 IO 上，所以读取速度快。
2. 整个 Redis 就是一个全局 哈希表，他的时间复杂度是 O(1)，而且为了防止哈希冲突导致链表过长，Redis 会执行 rehash 操作，扩充 哈希桶数量，减少哈希冲突。并且防止一次性 重新映射数据过大导致线程阻塞，采用 渐进式 rehash。巧妙的将一次性拷贝分摊到多次请求过程后总，避免阻塞。
3. Redis 使用的是非阻塞 IO：IO 多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，Redis 采用自己实现的事件分离器，效率比较高。
4. 采用单线程模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。
5. Redis 全程使用 hash 结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。
6. 根据实际存储的数据类型选择不同编码。

# redis 宕机如何快速恢复？
AOF日志和RDB快照

**生成 RDB 策略**

Redis 提供了两个指令用于生成 RDB 文件：
1. save： 主线程执行，会阻塞；
2. bgsave：调用 glibc 的函数fork产生一个子进程用于写入 RDB 文件，快照持久化完全交给子进程来处理，父进程继续处理客户端请求，生成 RDB 文件的默认配置。

Redis 使用操作系统的多进程写时复制技术 COW(Copy On Write) 来实现快照持久化。Redis 在持久化时会调用 glibc 的函数fork产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。这时你可以将父子进程想像成一个连体婴儿，共享身体。bgsave 子进程可以共享主线程的所有内存数据，读取主线程的数据并写入到 RDB 文件。在执行 SAVE 命令或者BGSAVE命令创建一个新的 RDB 文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的 RDB 文件中。当主线程执行写指令修改数据的时候，这个数据就会复制一份副本， bgsave 子进程读取这个副本数据写到 RDB 文件，所以主线程就可以直接修改原来的数据。

Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据。

**优缺点**

快照的恢复速度快，但是生成 RDB 文件频率不好把握，频率过低宕机丢失的数据就会比较多；太快，又会消耗额外开销。

RDB 采用二进制 + 数据压缩的方式写磁盘，文件体积小，数据恢复速度快。

**AOF 写后日志**

AOF 日志存储的是 Redis 服务器的顺序指令序列，AOF 日志只记录对内存进行修改的指令记录。

**写前与写后日志对比**

写前日志（Write Ahead Log, WAL）： 在实际写数据之前，将修改的数据写到日志文件中，故障恢复得以保证。

比如 MySQL Innodb 存储引擎 中的 redo log（重做日志）便是记录修改的数据日志，在实际修改数据前先记录修改日志在执行修改数据。

写后日志： 先执行「写」指令请求，将数据写入内存，再记录日志。

写后日志避免了额外的检查开销，不需要对执行的命令进行语法检查。如果使用写前日志的话，就需要先检查语法是否有误，否则日志记录了错误的命令，在使用日志恢复的时候就会出错。另外，写后才记录日志，不会阻塞当前的「写」指令执行。

AOF 避免了当前命令的阻塞，但是可能会给下一个命令带来阻塞的风险。AOF 日志是主线程执行，将日志写入磁盘过程中，如果磁盘压力大就会导致写磁盘很慢，导致后续的「写」指令阻塞。

**优缺点**

执行成功才记录日志，避免了指令语法检查开销。同时，不会阻塞当前「写」指令。

由于 AOF 记录的是一个个指令内容，具体格式请看上面的日志格式。故障恢复的时候需要执行每一个指令，如果日志文件太大，整个恢复过程就会非常缓慢。

**Redis 4.0 混合日志模型**

redis混合持久化。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。所以 RDB 内存快照以稍微慢一点的频率执行，在两次 RDB 快照期间使用 AOF 日志记录期间发生的所有「写」操作。这样快照就不用频繁的执行，同时由于 AOF 只需要记录两次快照之间发生的「写」指令，不需要记录所有的操作，避免出现文件过大的情况。

# 什么是事务的ACID？
事务（Transaction）是并发控制单位，一个操作序列组合而成，这些操作要么都执行，要么都不执行。

事务在执行时，会提供专门的属性保证：
- 原子性（Atomicity）：一个事务的多个操作必须完成，或者都不完成
- 一致性（Consistency）：事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后顺序都是合法数据状态。
- 隔离性（Isolation）：事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- 持久性（Durability）：事务一旦提交，所有的修改将永久的保存到数据库中，即使系统崩溃重启后数据也不会丢失。

# Redis 如何实现事务？
MULTI、EXEC、DISCARD 和 WATCH 命令是 Redis 实现事务的的基础。

Redis 事务的执行过程包含三个步骤：
1. 开启事务

客户端通过 MULTI 命令显式地表示开启一个事务，随后的命令将排队缓存，并不会实际执行。

2. 命令入队

客户端把事务中的要执行的一系列指令发送到服务端。需要注意的是，虽然指令发送到服务端，但是 Redis 实例只是把这一系列指令暂存在一个命令队列中，并不会立刻执行。

3. 执行事务或丢弃

客户端向服务端发送提交或者丢弃事务的命令，让 Redis 执行第二步中发送的具体指令或者清空队列命令，放弃执行。Redis 只需在调用 EXEC 时，即可安排队列命令执行。也可通过 DISCARD 丢弃第二步中保存在队列中的命令。

Redis 中并没有提供回滚机制。虽然 Redis 提供了 DISCARD 命令。 但是，这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。



# redis 事务是否满足ACID？
Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：

1. 批量指令在执行 EXEC 命令之前会放入队列暂存；
2. 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行；
3. 事务执行过程中，其他客户端提交的命令不会插入到当前命令执行的序列中。

**原子性**
- 命令入队时就报错，会放弃事务执行，保证原子性；
- 命令入队时没报错，实际执行时报错，不保证原子性；
- EXEC 命令执行时实例故障，如果开启了 AOF 日志，可以保证原子性。

**一致性**
- EXEC 执行前，入队报错。

事务会被放弃执行，所以可以保证一致性。

- EXEC 执行后，实际执行时报错。

有错误的执行不会执行，正确的指令可以正常执行，一致性可以保证。
- EXEC 执行时，实例故障。

实例故障后会进行重启，这就和数据恢复的方式有关了，我们要根据实例是否开启了 RDB 或 AOF 来分情况讨论下。如果我们没有开启 RDB 或 AOF，那么，实例故障重启后，数据都没有了，数据库是一致的。如果我们使用了 RDB 快照，因为 RDB 快照不会在事务执行时执行。所以，事务命令操作的结果不会被保存到 RDB 快照中，使用 RDB 快照进行恢复时，数据库里的数据也是一致的。如果我们使用了 AOF 日志，而事务操作还没有被记录到 AOF 日志时，实例就发生了故障，那么，使用 AOF 日志恢复的数据库数据是一致的。

如果只有部分操作被记录到了 AOF 日志，我们可以使用 redis-check-aof 清除事务中已经完成的操作，数据库恢复后也是一致的。

**隔离性**
- 并发操作在 EXEC 命令前执行，隔离性需要通过 WATCH 机制保证；
- 并发操作在 EXEC 命令之后，隔离性可以保证。

**隔离性**
- 如果 Redis 没有使用 RDB 或 AOF，那么事务的持久化属性肯定得不到保证。
- 如果 Redis 使用了 RDB 模式，那么，在一个事务执行后，而下一次的 RDB 快照还未执行前，如果发生了实例宕机，数据丢失，这种情况下，事务修改的数据也是不能保证持久化的。
- 如果 Redis 采用了 AOF 模式，因为 AOF 模式的三种配置选项 no、everysec 和 always 都会存在数据丢失的情况。
- 不管 Redis 采用什么持久化模式，事务的持久性属性是得不到保证的。

**总结**

- Redis 具备了一定的原子性，但不支持回滚。

- Redis 不具备 ACID 中一致性的概念。(或者说 Redis 在设计时就无视这点)

- Redis 具备隔离性。

- Redis 无法保证持久性。

Redis 的事务机制可以保证一致性和隔离性，但是无法保证持久性。

不过，因为 Redis 本身是内存数据库，持久性并不是一个必须的属性，我们更加关注的还是原子性、一致性和隔离性这三个属性。

